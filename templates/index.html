<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THE GAME ONLINE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        :root { 
            --felt-green: #0a5c36; 
            --my-turn-bg: #2e7d32; 
            --others-turn-bg: #c62828; 
            --bg-dark: #000000;
        }
        
        * { -webkit-tap-highlight-color: transparent; outline: none; box-sizing: border-box; font-family: sans-serif; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        html, body { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; position: fixed; background-color: var(--bg-dark); }
        body { background: radial-gradient(circle, #1a1a1a 0%, #000 100%); color: white; display: flex; flex-direction: column; align-items: center; }

        #splash { position: fixed; inset: 0; background: black; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 2000; transition: opacity 1s; }
        #splash h1 { font-size: 2.5rem; text-align: center; margin: 0; line-height: 1.2; letter-spacing: 0.3rem; }

        .screen { display: none; width: 100%; height: 100%; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        .screen.active { display: flex; }

        #stamp-btn { position: fixed; bottom: 20px; right: 20px; width: 50px; height: 50px; background: #fff; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; z-index: 1000; box-shadow: 0 4px 10px rgba(0,0,0,0.5); font-size: 1.5rem; color: #333; }
        #stamp-menu { position: fixed; bottom: 80px; right: 20px; background: rgba(255,255,255,0.95); padding: 10px; border-radius: 15px; display: none; flex-direction: column; z-index: 1000; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .stamp-option { padding: 10px 20px; color: #333; font-weight: bold; cursor: pointer; border-bottom: 1px solid #ddd; white-space: nowrap; font-family: 'Comic Sans MS', cursive, sans-serif; }
        .stamp-option:last-child { border: none; }

        .bubble { position: fixed; background: #fff; color: #333; padding: 10px 20px; border-radius: 20px; font-weight: bold; z-index: 1600; font-family: 'Comic Sans MS', cursive, sans-serif; box-shadow: 0 4px 10px rgba(0,0,0,0.3); animation: float-up 2s forwards; pointer-events: none; }
        .bubble::after { content: ''; position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%); border-width: 10px 10px 0; border-style: solid; border-color: #fff transparent transparent; }
        @keyframes float-up { 0% { opacity: 0; transform: translate(-50%, 0); } 10% { opacity: 1; transform: translate(-50%, -20px); } 80% { opacity: 1; transform: translate(-50%, -40px); } 100% { opacity: 0; transform: translate(-50%, -60px); } }

        #result-screen { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 3000; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        #result-screen h2 { font-size: 3.5rem; margin-bottom: 20px; text-shadow: 0 0 20px currentColor; }
        .perfect { color: #00ff00; } .win { color: #f1c40f; } .lose { color: #e74c3c; }
        #clear-notice { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 4rem; font-weight: bold; color: #f1c40f; text-shadow: 0 0 20px #000; z-index: 2500; pointer-events: none; opacity: 0; transition: opacity 0.5s; }

        #user-info-area { position: absolute; top: 20px; left: 20px; font-size: 0.9rem; border-bottom: 1px solid #666; cursor: pointer; padding: 5px; z-index: 100; }
        .btn { background: #333; color: white; border: 1px solid white; padding: 12px 25px; margin: 10px; font-size: 1.1rem; width: 220px; cursor: pointer; border-radius: 4px; }
        .btn-back { position: absolute; top: 20px; left: 20px; width: auto; padding: 8px 15px; font-size: 0.9rem; border: 1px solid white; background: #333; z-index: 100; }
        input { background: #000; color: white; border: 1px solid white; padding: 10px; font-size: 1.2rem; width: 220px; text-align: center; margin-bottom: 15px; -webkit-user-select: auto; user-select: auto; }

        #turn-indicator { width: 100%; padding: 10px; font-weight: bold; position: fixed; top: 0; left: 0; z-index: 10; display: none; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; }
        .my-turn { background: var(--my-turn-bg); } .others-turn { background: var(--others-turn-bg); }

        #game-info { font-size: 1.1rem; font-weight: bold; color: #ffffff; position: fixed; top: 45px; width: 100%; text-align: center; display: none; text-shadow: 0 0 5px rgba(0,0,0,1); z-index: 5; }
        #game-info span { color: #2ed573; font-size: 1.3rem; margin: 0 5px; }

        #game-area { width: 100%; height: 100%; display: none; text-align: center; padding-top: 80px; }
        #piles-display { display: none; background: var(--felt-green); padding: 15px; border-radius: 15px; border: 4px solid #4a3000; box-shadow: inset 0 0 50px rgba(0,0,0,0.5), 0 5px 15px rgba(0,0,0,0.8); margin: 5px auto; width: fit-content; }
        .piles-container { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; justify-content: center; }
        .pile-wrapper { display: flex; align-items: center; gap: 4px; }
        .arrow { font-size: 1.1rem; font-weight: bold; color: rgba(255,255,255,0.6); }
        .pile { height: 90px; width: 75px; border: 2px solid rgba(255,255,255,0.2); border-radius: 8px; display: flex; justify-content: center; align-items: center; background: rgba(0,0,0,0.3); position: relative; transition: 0.3s; }
        .pile.asc { border-color: #008cff; } .pile.desc { border-color: #ff3c00; }
        .pile-value { font-size: 1.8rem; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }

        @keyframes soft-glow { 0% { box-shadow: 0 0 0px #fff; } 50% { box-shadow: 0 0 30px #fff; background: rgba(255,255,255,0.2); } 100% { box-shadow: 0 0 0px #fff; } }
        .placed-effect { animation: soft-glow 0.8s ease-out; }

        .hand-container { margin-top: 5px; width: 100%; display: flex; flex-direction: column; align-items: center; }
        #hand { display: flex; flex-wrap: wrap; justify-content: center; gap: 4px; max-width: 320px; }
        
        /* „Ç´„Éº„Éâ„ÅÆ„Çπ„Çø„Ç§„É´Ôºö„Éâ„É©„ÉÉ„Ç∞‰∏≠„Å´ÊµÆ„Åç‰∏ä„Åå„ÇãÊºîÂá∫ËøΩÂä† */
        .card { 
            width: 46px; height: 68px; background: #fff; color: #000; border-radius: 4px; 
            font-size: 1.2rem; font-weight: bold; display: flex; justify-content: center; align-items: center; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.5); transition: transform 0.1s;
            touch-action: none; /* Ê®ôÊ∫ñ„ÅÆÊåôÂãï„ÇíÁÑ°ÂäπÂåñ */
        }
        .card-placeholder { width: 46px; height: 68px; }
        .dragging-active { position: fixed; pointer-events: none; z-index: 10000; transform: scale(1.2); opacity: 0.9; }

        #finish-btn.glow { animation: soft-glow 2s infinite; border-color: #fff; }
        #consult-box { background: rgba(0,0,0,0.6); padding: 15px; border-radius: 12px; margin: 0 auto 10px; width: 90%; max-width: 400px; border: 1px solid #444; }
        @keyframes moya { 0%, 100% { box-shadow: 0 0 5px #fff; } 50% { box-shadow: 0 0 25px #fff; } }
        .signal-glow { animation: moya 0.5s infinite; border-color: #fff !important; }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="splash"><h1>THE GAME<br>ONLINE</h1></div>
<div id="clear-notice">CLEAR</div>

<div id="stamp-ui" style="display:none;">
    <div id="stamp-btn" onclick="toggleStampMenu()">üí¨</div>
    <div id="stamp-menu"></div>
</div>

<div id="result-screen">
    <h2 id="result-text"></h2>
    <p id="result-subtext" style="margin-bottom: 30px;"></p>
    <button class="btn" onclick="location.reload()">„É°„Éã„É•„Éº„Å´Êàª„Çã</button>
</div>

<div id="name-screen" class="screen">
    <p>ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
    <input type="text" id="name-input" maxlength="10">
    <button class="btn" onclick="saveName()">Á¢∫ÂÆö</button>
</div>

<div id="menu-screen" class="screen">
    <div id="user-info-area" onclick="changeName()">ÂêçÂâç: <span id="display-name"></span></div>
    <h1 style="margin-bottom: 30px;">THE GAME</h1>
    <button class="btn" onclick="createRoom()">ÈÉ®Â±ã„Çí‰Ωú„Çã</button>
    <button class="btn" onclick="showScreen('join-screen')">ÈÉ®Â±ã„Å´ÂÖ•„Çã</button>
</div>

<div id="join-screen" class="screen">
    <button class="btn-back" onclick="showScreen('menu-screen')">Êàª„Çã</button>
    <p>ÈÉ®Â±ãÁï™Âè∑</p>
    <input type="number" id="room-input">
    <button id="join-confirm-btn" class="btn" onclick="joinRoom()">ÂèÇÂä†„Åô„Çã</button>
</div>

<div id="wait-screen" class="screen">
    <button class="btn-back" onclick="location.reload()">Êàª„Çã</button>
    <h2 id="room-id-val"></h2>
    <div id="player-list-wait" style="font-size: 1.2rem; margin-bottom: 20px;"></div>
    <div id="host-area" style="display:none;"><button class="btn" style="background:#2e7d32;" onclick="requestCards()">Âßã„ÇÅ„Çã</button></div>
    <p id="guest-msg">„Éõ„Çπ„Éà„ÅåÈñãÂßã„Åô„Çã„ÅÆ„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...</p>
</div>

<div id="game-area">
    <div id="turn-indicator"></div>
    <div id="game-info">Â±±Êú≠: <span id="deck-count">0</span> | Âá∫„Åó„ÅüÊûöÊï∞: <span id="played-count">0</span></div>

    <div id="piles-display">
        <div class="piles-container">
            <div class="pile-wrapper"><div class="arrow">‚Üë</div><div id="a1" class="pile asc" onclick="sendSignal('a1')"><div class="pile-value">1</div></div><div class="arrow">‚Üë</div></div>
            <div class="pile-wrapper"><div class="arrow">‚Üë</div><div id="a2" class="pile asc" onclick="sendSignal('a2')"><div class="pile-value">1</div></div><div class="arrow">‚Üë</div></div>
            <div class="pile-wrapper"><div class="arrow">‚Üì</div><div id="d1" class="pile desc" onclick="sendSignal('d1')"><div class="pile-value">100</div></div><div class="arrow">‚Üì</div></div>
            <div class="pile-wrapper"><div class="arrow">‚Üì</div><div id="d2" class="pile desc" onclick="sendSignal('d2')"><div class="pile-value">100</div></div><div class="arrow">‚Üì</div></div>
        </div>
    </div>

    <div id="consult-box" style="display:none;">
        <h3 style="margin:0;">Áõ∏Ë´á„Éï„Çß„Éº„Ç∫</h3>
        <div id="consult-list" style="margin:10px 0;"></div>
        <div id="host-setup" style="display:none;">
            <input type="number" id="first-num" placeholder="ÊúÄÂàù„ÅÆ‰∫∫„ÅÆÊï∞Â≠ó">
            <button class="btn" style="width:100%; margin:0;" onclick="confirmStart()">Ê±∫ÂÆö</button>
        </div>
    </div>

    <div class="hand-container">
        <div id="hand"></div>
        <button id="finish-btn" class="btn" style="display:none;" onclick="finishTurn()">„Çø„Éº„É≥ÁµÇ‰∫Ü</button>
    </div>
</div>

<script>
    const socket = io();
    let myName = localStorage.getItem('thegame_name') || "";
    let myRoom = null, isHost = false, myTurn = false, turnOrder = [], currentIdx = -1, consultNames = [], isStarted = false;
    let state = { deckCount: 0, hand: [], piles: {a1:1, a2:1, d1:100, d2:100}, played: 0, playerHands: {} };
    let clearNotified = false;

    // „Çø„ÉÉ„ÉÅÂà∂Âæ°Áî®Â§âÊï∞
    let touchDraggingCard = null;
    let dragClone = null;

    const waitStamps = ["„Çà„Çç„Åó„ÅèÔºÅ", "Êó©„ÅèÂßã„ÇÅ„Å¶ÔºÅ", "„Å∞„Éº„Åã", "È†ëÂºµ„Çç„ÅÜÔºÅ"];
    const gameStamps = ["„ÅØ„ÇÑ„Åè„Åä„ÅÑ„Å¶ÔºÅ", "„ÅÑ„ÅÑ„Å≠„Åá", "„ÇÑ„Çâ„Åã„Åó„Åü„Å™", "Á•û„ÅÆ‰∏ÄÊâã"];

    window.onload = () => { setTimeout(() => { document.getElementById('splash').style.opacity = '0'; setTimeout(() => { document.getElementById('splash').style.display = 'none'; if(!myName) showScreen('name-screen'); else showMenu(); }, 1000); }, 1000); };
    function showScreen(id) { document.querySelectorAll('.screen, #game-area').forEach(s => s.style.display = 'none'); document.getElementById(id).style.display = (id==='game-area'?'block':'flex'); }
    function saveName() { const v = document.getElementById('name-input').value.trim(); if(v){ myName = v; localStorage.setItem('thegame_name', v); showMenu(); } }
    function showMenu() { document.getElementById('display-name').innerText = myName; showScreen('menu-screen'); document.getElementById('stamp-ui').style.display = 'none'; }
    function changeName() { showScreen('name-screen'); }

    function createRoom() { isHost = true; socket.emit('create_room', {name: myName}); }
    function joinRoom() { myRoom = document.getElementById('room-input').value; if(myRoom) { isHost = false; socket.emit('join_room', {room_id: myRoom, name: myName}); document.getElementById('room-id-val').innerText = "ÈÉ®Â±ã: " + myRoom; showScreen('wait-screen'); } }
    
    socket.on('room_created', data => { myRoom = data.room_id; document.getElementById('room-id-val').innerText = "ÈÉ®Â±ã: "+data.room_id; updateWaitList(data.players); document.getElementById('host-area').style.display='block'; document.getElementById('guest-msg').style.display='none'; showScreen('wait-screen'); updateStampMenu(false); });
    socket.on('player_joined', data => { updateWaitList(data.players); });
    function updateWaitList(ps) { document.getElementById('player-list-wait').innerText = "„Éó„É¨„Ç§„É§„Éº: " + ps.join(', '); document.getElementById('stamp-ui').style.display = 'block'; updateStampMenu(false); }

    function requestCards() { socket.emit('request_initial_cards', {room_id: myRoom}); }

    socket.on('distribute_initial_cards', data => {
        showScreen('game-area');
        isStarted = true;
        updateStampMenu(true);
        state.deckCount = data.deck_count;
        state.hand = data.hands[myName].sort((a,b)=>a-b);
        consultNames = data.player_list;
        for(let name in data.hands) { state.playerHands[name] = data.hands[name].length; }
        document.getElementById('piles-display').style.display = 'none';
        document.getElementById('consult-box').style.display = 'block';
        document.getElementById('consult-list').innerHTML = consultNames.map((n,i)=>`${i+1}. ${n}`).join('<br>');
        if(isHost) document.getElementById('host-setup').style.display='block';
        if(data.num_players === 1) confirmStart(1);
        render();
    });

    function updateStampMenu(started) {
        const menu = document.getElementById('stamp-menu');
        const stamps = started ? gameStamps : waitStamps;
        menu.innerHTML = stamps.map(s => `<div class="stamp-option" onclick="sendStamp('${s}')">${s}</div>`).join('');
    }
    function toggleStampMenu() { const m = document.getElementById('stamp-menu'); m.style.display = m.style.display === 'flex' ? 'none' : 'flex'; }
    function sendStamp(msg) { socket.emit('send_stamp', { room_id: myRoom, name: myName, msg: msg }); toggleStampMenu(); }
    
    socket.on('receive_stamp', data => {
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.innerText = `${data.name}: ${data.msg}`;
        bubble.style.left = '50%';
        bubble.style.top = '50%';
        document.body.appendChild(bubble);
        setTimeout(() => bubble.remove(), 2000);
    });

    function confirmStart(n) { 
        let idx = n || document.getElementById('first-num').value;
        if(!idx || idx < 1 || idx > consultNames.length) return;
        socket.emit('confirm_first_player', { room_id: myRoom, firstPlayer: consultNames[idx-1] });
    }

    socket.on('start_game_with_order', data => {
        turnOrder = data.order; currentIdx = 0;
        document.getElementById('consult-box').style.display = 'none';
        document.getElementById('piles-display').style.display = 'block';
        document.getElementById('finish-btn').style.display = 'block';
        document.getElementById('turn-indicator').style.display = 'flex';
        document.getElementById('game-info').style.display = 'block';
        updateTurnDisplay(); render();
    });

    function updateTurnDisplay() {
        const cur = turnOrder[currentIdx];
        myTurn = (cur === myName);
        if(state.playerHands[cur] === 0) {
            if(checkAllHandsEmpty()) return;
            currentIdx = (currentIdx + 1) % turnOrder.length;
            updateTurnDisplay();
            return;
        }
        const nextIdx = (currentIdx + 1) % turnOrder.length;
        let nextP = turnOrder[nextIdx];
        let loopGuard = 0;
        while(state.playerHands[nextP] === 0 && loopGuard < turnOrder.length) {
            nextP = turnOrder[(nextIdx + loopGuard + 1) % turnOrder.length];
            loopGuard++;
        }
        document.getElementById('turn-indicator').innerText = myTurn ? `„ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥ (Ê¨°„ÅØ ${nextP})` : `${cur}„ÅÆ„Çø„Éº„É≥ (Ê¨°„ÅØ ${nextP})`;
        document.getElementById('turn-indicator').className = myTurn ? 'my-turn' : 'others-turn';
        if(myTurn) checkGameStatus();
    }

    function checkAllHandsEmpty() { return Object.values(state.playerHands).every(v => v === 0) && state.deckCount === 0; }

    function sendSignal(pid) { socket.emit('send_signal', { room_id: myRoom, pileId: pid }); }
    socket.on('receive_signal', data => {
        const p = document.getElementById(data.pileId);
        p.classList.add('signal-glow'); setTimeout(() => p.classList.remove('signal-glow'), 1500);
    });

    // --- ÊîπËâØÁâàÔºö„Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„Å´„Çà„Çã„Éâ„É©„ÉÉ„Ç∞Âà∂Âæ° ---
    function initTouchEvents(cardEl, value) {
        if (!myTurn) return;

        cardEl.ontouchstart = (e) => {
            if (!myTurn) return;
            const touch = e.touches[0];
            touchDraggingCard = value;

            // „ÇØ„É≠„Éº„É≥‰ΩúÊàê„Åó„Å¶ÊµÆ„Åã„Åõ„Çã
            dragClone = cardEl.cloneNode(true);
            dragClone.classList.add('dragging-active');
            dragClone.style.left = touch.clientX - 23 + 'px';
            dragClone.style.top = touch.clientY - 34 + 'px';
            document.body.appendChild(dragClone);
            
            cardEl.style.opacity = '0.3';
        };

        cardEl.ontouchmove = (e) => {
            if (!dragClone) return;
            const touch = e.touches[0];
            dragClone.style.left = touch.clientX - 23 + 'px';
            dragClone.style.top = touch.clientY - 34 + 'px';
        };

        cardEl.ontouchend = (e) => {
            if (!dragClone) return;
            const touch = e.changedTouches[0];
            const targetPile = document.elementFromPoint(touch.clientX, touch.clientY);
            
            // Èáç„Å™„Å£„Å¶„ÅÑ„ÇãË¶ÅÁ¥†„Åå pile „Åã„ÄÅ„Åù„ÅÆÂ≠êË¶ÅÁ¥†„ÅãÂà§ÂÆö
            const pileEl = targetPile ? targetPile.closest('.pile') : null;
            
            if (pileEl) {
                attemptPlaceCard(touchDraggingCard, pileEl.id);
            }

            document.body.removeChild(dragClone);
            dragClone = null;
            cardEl.style.opacity = '1';
            touchDraggingCard = null;
        };
    }

    function attemptPlaceCard(val, pid) {
        const top = state.piles[pid];
        const isAsc = pid.startsWith('a');
        if((isAsc && (val > top || val == top-10)) || (!isAsc && (val < top || val == top+10))) {
            state.piles[pid] = val; 
            state.hand[state.hand.indexOf(val)] = null; 
            state.played++;
            state.playerHands[myName]--;
            socket.emit('sync_move', { room_id: myRoom, pileId: pid, val: val, name: myName });
            render();
            checkGameStatus();
        }
    }

    socket.on('update_board', data => {
        state.piles[data.pileId] = data.val;
        state.playerHands[data.name]--;
        const p = document.getElementById(data.pileId);
        p.classList.add('placed-effect'); setTimeout(() => p.classList.remove('placed-effect'), 800);
        render();
    });

    socket.on('update_deck_count', data => { state.deckCount = data.deck_count; render(); });

    function checkGameStatus() {
        const totalRemaining = getTotalRemaining();
        const canMove = checkCanMove();
        const min = state.deckCount > 0 ? 2 : 1;
        const turnFinished = state.played >= min;
        if(totalRemaining === 0) { socket.emit('game_end', { room_id: myRoom, type: 'perfect', msg: 'PERFECT CLEAR', sub: '‰ºùË™¨„ÅÆ„ÉÅ„Éº„É†„ÉØ„Éº„ÇØ„Åß„ÅôÔºÅ' }); return; }
        if(!canMove && !turnFinished) {
            if(totalRemaining <= 9) { socket.emit('game_end', { room_id: myRoom, type: 'win', msg: 'CLEAR', sub: 'ÊÆã„Çä' + totalRemaining + 'ÊûöÔºÅÂãùÂà©„Åß„Åô„ÄÇ' }); }
            else { socket.emit('game_end', { room_id: myRoom, type: 'lose', msg: 'GAME OVER', sub: totalRemaining + 'ÊûöÊÆã„Åó...ÂÜçÊåëÊà¶„Åó„Åæ„Åó„Çá„ÅÜ' }); }
            return;
        }
        if(totalRemaining <= 9 && !clearNotified) { showClearNotice(); clearNotified = true; }
    }

    function getTotalRemaining() { const handTotal = Object.values(state.playerHands).reduce((a, b) => a + b, 0); return handTotal + state.deckCount; }

    function checkCanMove() {
        const hand = state.hand.filter(v => v !== null);
        for(let val of hand) {
            for(let pid in state.piles) {
                const top = state.piles[pid];
                const isAsc = pid.startsWith('a');
                if((isAsc && (val > top || val == top-10)) || (!isAsc && (val < top || val == top+10))) return true;
            }
        }
        return false;
    }

    function showClearNotice() { const el = document.getElementById('clear-notice'); el.style.opacity = '1'; setTimeout(() => el.style.opacity = '0', 1000); }

    socket.on('receive_game_end', data => {
        const screen = document.getElementById('result-screen');
        const text = document.getElementById('result-text');
        const sub = document.getElementById('result-subtext');
        text.innerText = data.msg; text.className = data.type; sub.innerText = data.sub; screen.style.display = 'flex';
        document.getElementById('stamp-ui').style.display = 'none';
    });

    function render() {
        for(let k in state.piles) {
            const el = document.querySelector(`#${k} .pile-value`);
            if(el) el.innerText = state.piles[k];
        }
        document.getElementById('deck-count').innerText = state.deckCount;
        document.getElementById('played-count').innerText = state.played;
        const h = document.getElementById('hand'); h.innerHTML = '';
        state.hand.forEach(v => {
            const d = document.createElement('div');
            if(v===null) d.className='card-placeholder';
            else { 
                d.className='card'; d.innerText=v;
                // „Çπ„Éû„ÉõÁî®„Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„ÉàÂàùÊúüÂåñ
                initTouchEvents(d, v);
            }
            h.appendChild(d);
        });

        const fb = document.getElementById('finish-btn'), min = state.deckCount > 0 ? 2 : 1;
        if(state.played >= min && myTurn) fb.classList.add('glow'); else fb.classList.remove('glow');
    }

    function finishTurn() {
        const min = state.deckCount > 0 ? 2 : 1;
        if(state.played < min || !myTurn) return;
        const drawCount = state.hand.filter(v=>v===null).length;
        socket.emit('draw_cards', { room_id: myRoom, count: drawCount, name: myName });
    }

    socket.on('receive_drawn_cards', data => {
        state.deckCount = data.deck_count;
        if(data.player_name === myName) {
            let dIdx = 0;
            state.hand = state.hand.map(v => (v === null && dIdx < data.cards.length) ? data.cards[dIdx++] : v).sort((a,b)=>a?b?a-b:-1:1);
            state.played = 0;
            state.playerHands[myName] = state.hand.filter(v => v !== null).length;
            currentIdx = (currentIdx + 1) % turnOrder.length;
            socket.emit('next_turn', { room_id: myRoom, nextIdx: currentIdx });
            updateTurnDisplay(); render();
        } else { state.playerHands[data.player_name] += data.cards.length; render(); }
    });

    socket.on('update_turn', data => { currentIdx = data.nextIdx; updateTurnDisplay(); render(); });
    socket.on('error', d => { alert(d.message); location.reload(); });
</script>
</body>
</html>
