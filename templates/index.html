<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THE GAME ONLINE</title>
    <link href="https://fonts.googleapis.com/css2?family=Potta+One&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        :root { 
            --felt-green: #0a5c36; 
            --my-turn-bg: #2e7d32; 
            --others-turn-bg: #c62828; 
            --bg-dark: #000000;
            --asc-blue: #00d2ff;
            --desc-red: #ff4b2b;
            --arrow-white: #ffffff; /* Áü¢Âç∞„ÇíË¶ã„ÇÑ„Åô„ÅèÁôΩ„Å´Ë®≠ÂÆö */
        }
        
        * { -webkit-tap-highlight-color: transparent; outline: none; box-sizing: border-box; font-family: sans-serif; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        html, body { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; position: fixed; background-color: var(--bg-dark); }
        body { background: radial-gradient(circle, #1a1a1a 0%, #000 100%); color: white; display: flex; flex-direction: column; align-items: center; }

        #splash { position: fixed; inset: 0; background: black; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 2000; transition: opacity 1s; }
        #splash h1 { font-size: 2.5rem; text-align: center; margin: 0; line-height: 1.2; letter-spacing: 0.3rem; }

        .screen { display: none; width: 100%; height: 100%; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        .screen.active { display: flex; }

        #turn-splash { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3.5rem; font-weight: bold; color: #fff; text-shadow: 0 0 20px #2e7d32; z-index: 2500; pointer-events: none; opacity: 0; transition: opacity 0.5s; font-family: 'Potta One', cursive; }

        #stamp-btn { position: fixed; bottom: 20px; right: 20px; width: 55px; height: 55px; background: #fff; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; z-index: 1000; box-shadow: 0 4px 10px rgba(0,0,0,0.5); font-size: 1.8rem; color: #333; }
        #stamp-menu { position: fixed; bottom: 85px; right: 20px; background: rgba(255,255,255,0.95); padding: 12px; border-radius: 16px; display: none; grid-template-columns: repeat(2, 1fr); gap: 10px; z-index: 1000; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .stamp-option { padding: 10px; color: #333; font-weight: bold; cursor: pointer; border: 1px solid #ddd; border-radius: 8px; background: #fff; text-align: center; font-family: 'Potta One', cursive; font-size: 0.8rem; white-space: nowrap; }

        .bubble { position: fixed; background: #fff; color: #333; padding: 12px 20px; border-radius: 20px; font-weight: bold; z-index: 1600; font-family: 'Potta One', cursive; box-shadow: 0 4px 12px rgba(0,0,0,0.3); animation: float-up 2s forwards; pointer-events: none; font-size: 1.1rem; white-space: nowrap; min-width: fit-content; }
        .bubble::after { content: ''; position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%); border-width: 10px 10px 0; border-style: solid; border-color: #fff transparent transparent; }
        @keyframes float-up { 0% { opacity: 0; transform: translate(-50%, 0); } 10% { opacity: 1; transform: translate(-50%, -20px); } 80% { opacity: 1; transform: translate(-50%, -40px); } 100% { opacity: 0; transform: translate(-50%, -60px); } }

        /* ÁâπÂæ¥ÁöÑ„Å™Áü¢Âç∞ÔºöÁôΩ„Åè„ÅØ„Å£„Åç„Çä„Åï„Åõ„Çã */
        .arrow-container { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; }
        .custom-arrow { width: 0; height: 0; border-left: 14px solid transparent; border-right: 14px solid transparent; position: relative; }
        .arrow-stem { width: 5px; height: 28px; background-color: var(--arrow-white); box-shadow: 0 0 8px rgba(255,255,255,0.5); }

        .asc-arrow-head { border-bottom: 20px solid var(--arrow-white); margin-bottom: -2px; filter: drop-shadow(0 -2px 5px rgba(255,255,255,0.5)); }
        .desc-arrow-head { border-top: 20px solid var(--arrow-white); margin-top: -2px; filter: drop-shadow(0 2px 5px rgba(255,255,255,0.5)); }

        #result-screen { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 3000; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        #result-screen h2 { font-size: 3.5rem; margin-bottom: 20px; text-shadow: 0 0 20px currentColor; font-family: 'Potta One', cursive; }
        .perfect { color: #00ff00; } .win { color: #f1c40f; } .lose { color: #e74c3c; }
        #clear-notice { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 4rem; font-weight: bold; color: #f1c40f; text-shadow: 0 0 20px #000; z-index: 2500; pointer-events: none; opacity: 0; transition: opacity 0.5s; font-family: 'Potta One', cursive; }

        #user-info-area { position: absolute; top: 20px; left: 20px; font-size: 0.9rem; border-bottom: 1px solid #666; cursor: pointer; padding: 5px; z-index: 100; }
        .btn { background: #333; color: white; border: 1px solid white; padding: 12px 25px; margin: 10px; font-size: 1.1rem; width: 220px; cursor: pointer; border-radius: 4px; }
        .btn-back { position: absolute; top: 20px; left: 20px; width: auto; padding: 8px 15px; font-size: 0.9rem; border: 1px solid white; background: #333; z-index: 100; }
        input { background: #000; color: white; border: 1px solid white; padding: 10px; font-size: 1.2rem; width: 220px; text-align: center; margin-bottom: 15px; }

        #turn-indicator { width: 100%; padding: 10px; font-weight: bold; position: fixed; top: 0; left: 0; z-index: 10; display: none; font-size: 0.9rem; box-shadow: 0 2px 10px rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; }
        .my-turn { background: var(--my-turn-bg); } .others-turn { background: var(--others-turn-bg); }

        #game-info { font-size: 1.1rem; font-weight: bold; color: #ffffff; position: fixed; top: 45px; width: 100%; text-align: center; display: none; text-shadow: 0 0 5px rgba(0,0,0,1); z-index: 5; }
        #game-info span { color: #2ed573; font-size: 1.3rem; margin: 0 5px; }

        #game-area { width: 100%; height: 100%; display: none; text-align: center; padding-top: 80px; }
        
        /* Êç®„Å¶Â†¥„Éá„Ç∂„Ç§„É≥ÔºöÊû†„ÅÆËâ≤„Å®ÈÖçÁΩÆ„ÅÆ‰øÆÊ≠£ */
        #piles-display { 
            display: none; background: var(--felt-green); padding: 25px; 
            border-radius: 40px; border: 3px solid #1a2a24; 
            box-shadow: inset 0 0 60px rgba(0,0,0,0.6), 0 8px 20px rgba(0,0,0,0.8); 
            margin: 5px auto; width: 95%; max-width: 440px;
        }
        .piles-grid { 
            display: grid; 
            grid-template-columns: 140px 40px 140px; /* PC„Åß„ÇÇ‰∏≠Â§Æ„Å´Áü¢Âç∞„ÅåÊù•„Çã„Çà„ÅÜÂπÖ„ÇíÂõ∫ÂÆö */
            grid-template-rows: 1fr 1fr; 
            gap: 15px; 
            align-items: center;
            justify-content: center;
        }

        .pile { 
            height: 75px; width: 130px; 
            border: 3px solid #1a2a24; border-radius: 15px; 
            display: flex; justify-content: center; align-items: center; 
            background: #ffffff; color: #333;
            position: relative; transition: 0.3s; 
        }
        /* ÊòáÈ†Ü„ÉªÈôçÈ†Ü„ÅÆËâ≤„ÇíÊàª„Åô */
        .pile.asc { border-color: var(--asc-blue); box-shadow: 0 0 10px rgba(0, 210, 255, 0.3); }
        .pile.desc { border-color: var(--desc-red); box-shadow: 0 0 10px rgba(255, 75, 43, 0.3); }
        .pile-value { font-size: 2.2rem; font-weight: bold; }

        @keyframes soft-glow { 0% { box-shadow: 0 0 0px #fff; } 50% { box-shadow: 0 0 35px #fff; } 100% { box-shadow: 0 0 0px #fff; } }
        .placed-effect { animation: soft-glow 0.8s ease-out; }

        .hand-container { margin-top: 5px; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .hand-row { display: flex; justify-content: center; gap: 6px; min-height: 72px; }
        
        .card { width: 48px; height: 72px; background: #fff; color: #000; border-radius: 5px; font-size: 1.3rem; font-weight: bold; display: flex; justify-content: center; align-items: center; box-shadow: 0 3px 6px rgba(0,0,0,0.5); transition: transform 0.1s; touch-action: none; }
        .card-placeholder { width: 48px; height: 72px; }
        .dragging-active { position: fixed; pointer-events: none; z-index: 10000; transform: scale(1.15); opacity: 0.95; box-shadow: 0 10px 20px rgba(0,0,0,0.6); }

        #finish-btn.glow { animation: soft-glow 2s infinite; border-color: #fff; }
        #consult-box { background: rgba(0,0,0,0.7); padding: 18px; border-radius: 15px; margin: 0 auto 10px; width: 90%; max-width: 400px; border: 1px solid #555; }
        @keyframes moya { 0%, 100% { box-shadow: 0 0 5px #fff; } 50% { box-shadow: 0 0 30px #fff; } }
        .signal-glow { animation: moya 0.5s infinite; border-color: #fff !important; }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="splash"><h1>THE GAME<br>ONLINE</h1></div>
<div id="turn-splash">„ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥</div>
<div id="clear-notice">CLEAR</div>

<div id="stamp-ui" style="display:none;">
    <div id="stamp-btn" onclick="toggleStampMenu()">üí¨</div>
    <div id="stamp-menu"></div>
</div>

<div id="result-screen">
    <h2 id="result-text"></h2>
    <p id="result-subtext" style="margin-bottom: 30px;"></p>
    <button class="btn" onclick="location.reload()">„É°„Éã„É•„Éº„Å´Êàª„Çã</button>
</div>

<div id="name-screen" class="screen">
    <p>ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
    <input type="text" id="name-input" maxlength="10">
    <button class="btn" onclick="saveName()">Á¢∫ÂÆö</button>
</div>

<div id="menu-screen" class="screen">
    <div id="user-info-area" onclick="changeName()">ÂêçÂâç: <span id="display-name"></span></div>
    <h1 style="margin-bottom: 30px;">THE GAME</h1>
    <button class="btn" onclick="createRoom()">ÈÉ®Â±ã„Çí‰Ωú„Çã</button>
    <button class="btn" onclick="showScreen('join-screen')">ÈÉ®Â±ã„Å´ÂÖ•„Çã</button>
</div>

<div id="join-screen" class="screen">
    <button class="btn-back" onclick="showScreen('menu-screen')">Êàª„Çã</button>
    <p>ÈÉ®Â±ãÁï™Âè∑</p>
    <input type="number" id="room-input">
    <button id="join-confirm-btn" class="btn" onclick="joinRoom()">ÂèÇÂä†„Åô„Çã</button>
</div>

<div id="wait-screen" class="screen">
    <button class="btn-back" onclick="location.reload()">Êàª„Çã</button>
    <h2 id="room-id-val"></h2>
    <div id="player-list-wait" style="font-size: 1.2rem; margin-bottom: 20px;"></div>
    <div id="host-area" style="display:none;"><button class="btn" style="background:#2e7d32;" onclick="requestCards()">Âßã„ÇÅ„Çã</button></div>
    <p id="guest-msg">„Éõ„Çπ„Éà„ÅåÈñãÂßã„Åô„Çã„ÅÆ„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...</p>
</div>

<div id="game-area">
    <div id="turn-indicator"></div>
    <div id="game-info">Â±±Êú≠: <span id="deck-count">0</span> | Âá∫„Åó„ÅüÊûöÊï∞: <span id="played-count">0</span></div>

    <div id="piles-display">
        <div class="piles-grid">
            <div id="a1" class="pile asc" onclick="sendSignal('a1')"><div class="pile-value">1</div></div>
            <div class="arrow-container">
                <div class="custom-arrow asc-arrow-head"></div>
                <div class="arrow-stem"></div>
            </div>
            <div id="a2" class="pile asc" onclick="sendSignal('a2')"><div class="pile-value">1</div></div>

            <div id="d1" class="pile desc" onclick="sendSignal('d1')"><div class="pile-value">100</div></div>
            <div class="arrow-container">
                <div class="arrow-stem"></div>
                <div class="custom-arrow desc-arrow-head"></div>
            </div>
            <div id="d2" class="pile desc" onclick="sendSignal('d2')"><div class="pile-value">100</div></div>
        </div>
    </div>

    <div id="consult-box" style="display:none;">
        <h3 style="margin:0;">Áõ∏Ë´á„Éï„Çß„Éº„Ç∫</h3>
        <div id="consult-list" style="margin:10px 0;"></div>
        <div id="host-setup" style="display:none;">
            <input type="number" id="first-num" placeholder="ÊúÄÂàù„ÅÆ‰∫∫„ÅÆÊï∞Â≠ó">
            <button class="btn" style="width:100%; margin:0;" onclick="confirmStart()">Ê±∫ÂÆö</button>
        </div>
    </div>

    <div class="hand-container">
        <div id="hand-row-top" class="hand-row"></div>
        <div id="hand-row-bottom" class="hand-row"></div>
        <button id="finish-btn" class="btn" style="display:none;" onclick="finishTurn()">„Çø„Éº„É≥ÁµÇ‰∫Ü</button>
    </div>
</div>

<script>
    const socket = io();
    let myName = localStorage.getItem('thegame_name') || "";
    let myRoom = null, isHost = false, myTurn = false, turnOrder = [], currentIdx = -1, consultNames = [], isStarted = false;
    let state = { deckCount: 0, hand: [], piles: {a1:1, a2:1, d1:100, d2:100}, played: 0, playerHands: {} };
    let clearNotified = false;
    let draggingData = { cardValue: null, el: null, clone: null };

    const waitStamps = ["„Çà„Çç„Åó„ÅèÔºÅ", "Êó©„ÅèÂßã„ÇÅ„Å¶ÔºÅ", "„Å∞„Éº„Åã", "È†ëÂºµ„Çç„ÅÜÔºÅ"];
    const gameStamps = ["„ÅØ„ÇÑ„Åè„Åä„ÅÑ„Å¶ÔºÅ", "„ÅÑ„ÅÑ„Å≠„Åá", "„ÇÑ„Çâ„Åã„Åó„Åü„Å™", "Á•û„ÅÆ‰∏ÄÊâã"];

    window.onload = () => { setTimeout(() => { document.getElementById('splash').style.opacity = '0'; setTimeout(() => { document.getElementById('splash').style.display = 'none'; if(!myName) showScreen('name-screen'); else showMenu(); }, 1000); }, 1000); };
    function showScreen(id) { document.querySelectorAll('.screen, #game-area').forEach(s => s.style.display = 'none'); document.getElementById(id).style.display = (id==='game-area'?'block':'flex'); }
    function saveName() { const v = document.getElementById('name-input').value.trim(); if(v){ myName = v; localStorage.setItem('thegame_name', v); showMenu(); } }
    function showMenu() { document.getElementById('display-name').innerText = myName; showScreen('menu-screen'); document.getElementById('stamp-ui').style.display = 'none'; }
    function changeName() { showScreen('name-screen'); }

    function createRoom() { isHost = true; socket.emit('create_room', {name: myName}); }
    function joinRoom() { myRoom = document.getElementById('room-input').value; if(myRoom) { isHost = false; socket.emit('join_room', {room_id: myRoom, name: myName}); document.getElementById('room-id-val').innerText = "ÈÉ®Â±ã: " + myRoom; showScreen('wait-screen'); } }
    
    socket.on('room_created', data => { myRoom = data.room_id; document.getElementById('room-id-val').innerText = "ÈÉ®Â±ã: "+data.room_id; updateWaitList(data.players); document.getElementById('host-area').style.display='block'; document.getElementById('guest-msg').style.display='none'; showScreen('wait-screen'); updateStampMenu(false); });
    socket.on('player_joined', data => { updateWaitList(data.players); });
    function updateWaitList(ps) { document.getElementById('player-list-wait').innerText = "„Éó„É¨„Ç§„É§„Éº: " + ps.join(', '); document.getElementById('stamp-ui').style.display = 'block'; updateStampMenu(false); }

    function requestCards() { socket.emit('request_initial_cards', {room_id: myRoom}); }

    socket.on('distribute_initial_cards', data => {
        showScreen('game-area');
        isStarted = true;
        updateStampMenu(true);
        state.deckCount = data.deck_count;
        state.hand = data.hands[myName].sort((a,b)=>a-b);
        consultNames = data.player_list;
        for(let name in data.hands) { state.playerHands[name] = data.hands[name].length; }
        document.getElementById('piles-display').style.display = 'none';
        document.getElementById('consult-box').style.display = 'block';
        document.getElementById('consult-list').innerHTML = consultNames.map((n,i)=>`${i+1}. ${n}`).join('<br>');
        if(isHost) document.getElementById('host-setup').style.display='block';
        if(data.num_players === 1) confirmStart(1);
        render();
    });

    function updateStampMenu(started) {
        const menu = document.getElementById('stamp-menu');
        const stamps = started ? gameStamps : waitStamps;
        menu.innerHTML = stamps.map(s => `<div class="stamp-option" onclick="sendStamp('${s}')">${s}</div>`).join('');
    }
    function toggleStampMenu() { const m = document.getElementById('stamp-menu'); m.style.display = m.style.display === 'grid' ? 'none' : 'grid'; }
    function sendStamp(msg) { socket.emit('send_stamp', { room_id: myRoom, name: myName, msg: msg }); toggleStampMenu(); }
    
    socket.on('receive_stamp', data => {
        const bubble = document.createElement('div');
        bubble.className = 'bubble'; bubble.innerText = `${data.name}: ${data.msg}`;
        bubble.style.left = '50%'; bubble.style.top = '50%';
        document.body.appendChild(bubble); setTimeout(() => bubble.remove(), 2000);
    });

    function confirmStart(n) { 
        let idx = n || document.getElementById('first-num').value;
        if(!idx || idx < 1 || idx > consultNames.length) return;
        socket.emit('confirm_first_player', { room_id: myRoom, firstPlayer: consultNames[idx-1] });
    }

    socket.on('start_game_with_order', data => {
        turnOrder = data.order; currentIdx = 0;
        document.getElementById('consult-box').style.display = 'none';
        document.getElementById('piles-display').style.display = 'block';
        document.getElementById('finish-btn').style.display = 'block';
        document.getElementById('turn-indicator').style.display = 'flex';
        document.getElementById('game-info').style.display = 'block';
        updateTurnDisplay(); render();
    });

    function updateTurnDisplay() {
        const cur = turnOrder[currentIdx];
        myTurn = (cur === myName);
        if(state.playerHands[cur] === 0) {
            if(checkAllHandsEmpty()) return;
            currentIdx = (currentIdx + 1) % turnOrder.length;
            updateTurnDisplay(); return;
        }
        const nextIdx = (currentIdx + 1) % turnOrder.length;
        let nextP = turnOrder[nextIdx];
        let loopGuard = 0;
        while(state.playerHands[nextP] === 0 && loopGuard < turnOrder.length) {
            nextP = turnOrder[(nextIdx + loopGuard + 1) % turnOrder.length];
            loopGuard++;
        }
        document.getElementById('turn-indicator').innerText = myTurn ? `„ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥ (Ê¨°„ÅØ ${nextP})` : `${cur}„ÅÆ„Çø„Éº„É≥ (Ê¨°„ÅØ ${nextP})`;
        document.getElementById('turn-indicator').className = myTurn ? 'my-turn' : 'others-turn';
        if(myTurn) {
            const sp = document.getElementById('turn-splash');
            sp.style.opacity = '1';
            setTimeout(() => sp.style.opacity = '0', 1000);
            checkGameStatus();
        }
    }

    function checkAllHandsEmpty() { return Object.values(state.playerHands).every(v => v === 0) && state.deckCount === 0; }

    function sendSignal(pid) { socket.emit('send_signal', { room_id: myRoom, pileId: pid }); }
    socket.on('receive_signal', data => {
        const p = document.getElementById(data.pileId);
        p.classList.add('signal-glow'); setTimeout(() => p.classList.remove('signal-glow'), 1500);
    });

    function initDragEvents(cardEl, value) {
        const startDrag = (x, y) => {
            if (!myTurn) return;
            draggingData.cardValue = value;
            draggingData.el = cardEl;
            draggingData.clone = cardEl.cloneNode(true);
            draggingData.clone.classList.add('dragging-active');
            updateClonePos(x, y);
            document.body.appendChild(draggingData.clone);
            cardEl.style.opacity = '0.3';
        };

        const updateClonePos = (x, y) => {
            if (!draggingData.clone) return;
            draggingData.clone.style.left = (x - 24) + 'px';
            draggingData.clone.style.top = (y - 36) + 'px';
        };

        const endDrag = (x, y) => {
            if (!draggingData.clone) return;
            const target = document.elementFromPoint(x, y);
            const pile = target ? target.closest('.pile') : null;
            if (pile) attemptPlaceCard(draggingData.cardValue, pile.id);
            
            document.body.removeChild(draggingData.clone);
            draggingData.clone = null;
            cardEl.style.opacity = '1';
        };

        cardEl.onmousedown = (e) => {
            startDrag(e.clientX, e.clientY);
            window.onmousemove = (me) => updateClonePos(me.clientX, me.clientY);
            window.onmouseup = (ue) => { endDrag(ue.clientX, ue.clientY); window.onmousemove = null; window.onmouseup = null; };
        };
        cardEl.ontouchstart = (e) => { startDrag(e.touches[0].clientX, e.touches[0].clientY); };
        cardEl.ontouchmove = (e) => updateClonePos(e.touches[0].clientX, e.touches[0].clientY);
        cardEl.ontouchend = (e) => endDrag(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    }

    function attemptPlaceCard(val, pid) {
        const top = state.piles[pid], isAsc = pid.startsWith('a');
        if((isAsc && (val > top || val == top-10)) || (!isAsc && (val < top || val == top+10))) {
            state.piles[pid] = val; 
            const idx = state.hand.indexOf(val);
            state.hand[idx] = null;
            state.played++;
            state.playerHands[myName]--;
            socket.emit('sync_move', { room_id: myRoom, pileId: pid, val: val, name: myName });
            render(); checkGameStatus();
        }
    }

    socket.on('update_board', data => {
        state.piles[data.pileId] = data.val;
        state.playerHands[data.name]--;
        const p = document.getElementById(data.pileId);
        p.classList.add('placed-effect'); setTimeout(() => p.classList.remove('placed-effect'), 800);
        render();
    });

    socket.on('update_deck_count', data => { state.deckCount = data.deck_count; render(); });

    function checkGameStatus() {
        const totalRemaining = getTotalRemaining();
        const canMove = checkCanMove();
        const min = state.deckCount > 0 ? 2 : 1;
        const turnFinished = state.played >= min;
        if(totalRemaining === 0) { socket.emit('game_end', { room_id: myRoom, type: 'perfect', msg: 'PERFECT CLEAR', sub: '‰ºùË™¨„ÅÆ„ÉÅ„Éº„É†„ÉØ„Éº„ÇØ„Åß„ÅôÔºÅ' }); return; }
        if(!canMove && !turnFinished) {
            if(totalRemaining <= 9) socket.emit('game_end', { room_id: myRoom, type: 'win', msg: 'CLEAR', sub: 'ÊÆã„Çä' + totalRemaining + 'ÊûöÔºÅÂãùÂà©„Åß„Åô„ÄÇ' });
            else socket.emit('game_end', { room_id: myRoom, type: 'lose', msg: 'GAME OVER', sub: totalRemaining + 'ÊûöÊÆã„Åó...' });
            return;
        }
        if(totalRemaining <= 9 && !clearNotified) { showClearNotice(); clearNotified = true; }
    }

    function getTotalRemaining() { return Object.values(state.playerHands).reduce((a, b) => a + b, 0) + state.deckCount; }
    function checkCanMove() {
        const hand = state.hand.filter(v => v !== null);
        for(let val of hand) {
            for(let pid in state.piles) {
                const top = state.piles[pid], isAsc = pid.startsWith('a');
                if((isAsc && (val > top || val == top-10)) || (!isAsc && (val < top || val == top+10))) return true;
            }
        }
        return false;
    }

    function showClearNotice() { const el = document.getElementById('clear-notice'); el.style.opacity = '1'; setTimeout(() => el.style.opacity = '0', 1000); }

    socket.on('receive_game_end', data => {
        const screen = document.getElementById('result-screen');
        document.getElementById('result-text').innerText = data.msg;
        document.getElementById('result-text').className = data.type;
        document.getElementById('result-subtext').innerText = data.sub;
        screen.style.display = 'flex';
        document.getElementById('stamp-ui').style.display = 'none';
    });

    function render() {
        for(let k in state.piles) {
            const el = document.querySelector(`#${k} .pile-value`);
            if(el) el.innerText = state.piles[k];
        }
        document.getElementById('deck-count').innerText = state.deckCount;
        document.getElementById('played-count').innerText = state.played;
        
        const rowTop = document.getElementById('hand-row-top');
        const rowBottom = document.getElementById('hand-row-bottom');
        rowTop.innerHTML = ''; rowBottom.innerHTML = '';

        let topCount = 4;
        if(state.hand.length === 6) topCount = 3;

        state.hand.forEach((v, i) => {
            const d = document.createElement('div');
            if(v === null) d.className = 'card-placeholder';
            else { d.className = 'card'; d.innerText = v; initDragEvents(d, v); }
            if(i < topCount) rowTop.appendChild(d); else rowBottom.appendChild(d);
        });

        const fb = document.getElementById('finish-btn'), min = state.deckCount > 0 ? 2 : 1;
        if(state.played >= min && myTurn) fb.classList.add('glow'); else fb.classList.remove('glow');
    }

    function finishTurn() {
        const min = state.deckCount > 0 ? 2 : 1;
        if(state.played < min || !myTurn) return;
        const drawCount = state.hand.filter(v=>v===null).length;
        socket.emit('draw_cards', { room_id: myRoom, count: drawCount, name: myName });
    }

    socket.on('receive_drawn_cards', data => {
        state.deckCount = data.deck_count;
        if(data.player_name === myName) {
            let existing = state.hand.filter(v => v !== null);
            let combined = [...existing, ...data.cards].sort((a,b) => a-b);
            state.hand = combined;
            state.played = 0; state.playerHands[myName] = state.hand.length;
            currentIdx = (currentIdx + 1) % turnOrder.length;
            socket.emit('next_turn', { room_id: myRoom, nextIdx: currentIdx });
            updateTurnDisplay(); render();
        } else { state.playerHands[data.player_name] += data.cards.length; render(); }
    });

    socket.on('update_turn', data => { currentIdx = data.nextIdx; updateTurnDisplay(); render(); });
    socket.on('error', d => { alert(d.message); location.reload(); });
</script>
</body>
</html>
